defmodule EveDmv.Contexts.ThreatAssessment.Analyzers.VulnerabilityScanner do
  @moduledoc """
  Vulnerability scanner for threat assessment.

  Scans entities (characters, corporations, fleets) for potential vulnerabilities
  including behavioral patterns, tactical weaknesses, security gaps, and
  exploitable characteristics that could be leveraged in threat scenarios.
  """

  use EveDmv.ErrorHandler
  alias EveDmv.Result
  require Logger

  @doc """
  Analyze vulnerabilities for an entity.

  Returns a comprehensive vulnerability analysis including behavioral,
  tactical, operational, and social vulnerabilities.
  """
  @spec analyze(integer(), map(), keyword()) :: Result.t(map())
  def analyze(entity_id, base_data, opts \\ []) when is_integer(entity_id) do
    start_time = System.monotonic_time()

    try do
      entity_type = Keyword.get(opts, :entity_type, :character)

      with {:ok, entity_data} <- get_entity_data(base_data, entity_id, entity_type),
           {:ok, related_data} <- get_related_data(base_data, entity_id, entity_type) do
        vulnerability_analysis = %{
          entity_profile: analyze_entity_profile(entity_data, entity_type),
          behavioral_vulnerabilities:
            analyze_behavioral_vulnerabilities(entity_data, related_data),
          tactical_vulnerabilities: analyze_tactical_vulnerabilities(entity_data, related_data),
          operational_vulnerabilities:
            analyze_operational_vulnerabilities(entity_data, related_data),
          social_vulnerabilities: analyze_social_vulnerabilities(entity_data, related_data),
          security_assessment: perform_security_assessment(entity_data, related_data),
          exploitability_rating: calculate_exploitability_rating(entity_data, related_data),
          vulnerability_summary:
            generate_vulnerability_summary(entity_data, related_data, entity_type)
        }

        duration_ms =
          System.convert_time_unit(System.monotonic_time() - start_time, :native, :millisecond)

        Logger.info("Vulnerability scan completed",
          entity_id: entity_id,
          entity_type: entity_type,
          duration_ms: duration_ms
        )

        Result.ok(vulnerability_analysis)
      end
    rescue
      exception ->
        duration_ms =
          System.convert_time_unit(System.monotonic_time() - start_time, :native, :millisecond)

        Logger.error("Vulnerability scan failed",
          entity_id: entity_id,
          duration_ms: duration_ms,
          error: Exception.format(:error, exception)
        )

        Result.error(
          :vulnerability_scan_failed,
          "Vulnerability scan error: #{inspect(exception)}"
        )
    end
  end

  # Analysis implementation

  defp analyze_entity_profile(entity_data, entity_type) do
    case entity_type do
      :character ->
        %{
          entity_type: :character,
          character_id: entity_data.character_id,
          character_name: entity_data.character_name,
          corporation_id: entity_data.corporation_id,
          alliance_id: entity_data.alliance_id,
          security_status: entity_data.security_status || 0.0,
          age_days: calculate_character_age(entity_data),
          activity_level: categorize_activity_level(entity_data),
          primary_timezone: entity_data.prime_timezone
        }

      :corporation ->
        %{
          entity_type: :corporation,
          corporation_id: entity_data.corporation_id,
          corporation_name: entity_data.corporation_name,
          alliance_id: entity_data.alliance_id,
          member_count: entity_data.member_count || 0,
          founded_date: entity_data.founded_date,
          ceo_id: entity_data.ceo_id,
          activity_level: categorize_corp_activity_level(entity_data)
        }

      :fleet ->
        %{
          entity_type: :fleet,
          fleet_id: entity_data.fleet_id,
          fleet_name: entity_data.fleet_name,
          participant_count: entity_data.participant_count || 0,
          fleet_commander: entity_data.fleet_commander,
          fleet_type: entity_data.fleet_type,
          engagement_context: entity_data.engagement_context
        }
    end
  end

  defp analyze_behavioral_vulnerabilities(entity_data, related_data) do
    # Analyze behavioral patterns that could be exploited
    behavioral_patterns = extract_behavioral_patterns(entity_data, related_data)

    vulnerabilities = %{
      predictable_patterns: identify_predictable_patterns(behavioral_patterns),
      routine_weaknesses: identify_routine_weaknesses(behavioral_patterns),
      emotional_triggers: identify_emotional_triggers(entity_data),
      decision_making_flaws: analyze_decision_patterns(related_data),
      social_engineering_susceptibility: assess_social_engineering_risk(entity_data),
      information_disclosure_risk: assess_information_leakage(entity_data, related_data)
    }

    # Calculate behavioral vulnerability score
    behavioral_score = calculate_behavioral_vulnerability_score(vulnerabilities)

    %{
      vulnerabilities: vulnerabilities,
      behavioral_vulnerability_score: behavioral_score,
      exploitation_vectors: identify_behavioral_exploitation_vectors(vulnerabilities),
      mitigation_recommendations: suggest_behavioral_mitigations(vulnerabilities)
    }
  end

  defp analyze_tactical_vulnerabilities(entity_data, related_data) do
    # Analyze tactical and combat-related vulnerabilities
    tactical_analysis = %{
      combat_patterns: analyze_combat_vulnerability_patterns(entity_data, related_data),
      ship_preferences: analyze_ship_vulnerability_patterns(entity_data),
      fitting_weaknesses: identify_fitting_vulnerabilities(entity_data),
      engagement_preferences: analyze_engagement_vulnerabilities(entity_data),
      fleet_coordination: assess_coordination_vulnerabilities(entity_data, related_data),
      escape_patterns: analyze_escape_route_vulnerabilities(entity_data)
    }

    # Identify specific tactical exploits
    tactical_exploits = %{
      ship_counters: identify_ship_counter_opportunities(entity_data),
      range_exploits: identify_range_exploitation_opportunities(entity_data),
      timing_exploits: identify_timing_vulnerabilities(entity_data),
      positioning_weaknesses: identify_positioning_vulnerabilities(entity_data)
    }

    tactical_score = calculate_tactical_vulnerability_score(tactical_analysis, tactical_exploits)

    %{
      tactical_analysis: tactical_analysis,
      exploitation_opportunities: tactical_exploits,
      tactical_vulnerability_score: tactical_score,
      recommended_counter_strategies: suggest_counter_strategies(tactical_analysis),
      vulnerability_rating: categorize_tactical_vulnerability(tactical_score)
    }
  end

  defp analyze_operational_vulnerabilities(entity_data, related_data) do
    # Analyze operational security and procedural vulnerabilities
    operational_gaps = %{
      security_practices: assess_security_practices(entity_data),
      information_security: assess_information_security(entity_data, related_data),
      operational_patterns: identify_operational_patterns(entity_data, related_data),
      asset_exposure: assess_asset_exposure_risk(entity_data),
      communication_security: assess_communication_vulnerabilities(entity_data),
      logistical_vulnerabilities: identify_logistical_weaknesses(entity_data)
    }

    # Calculate operational risk factors
    risk_factors = %{
      insider_threat_risk: assess_insider_threat_risk(entity_data),
      supply_chain_vulnerabilities: assess_supply_chain_risks(entity_data),
      operational_tempo_risks: assess_operational_tempo_vulnerabilities(entity_data),
      geographic_vulnerabilities: assess_geographic_vulnerabilities(entity_data)
    }

    operational_score = calculate_operational_vulnerability_score(operational_gaps, risk_factors)

    %{
      operational_gaps: operational_gaps,
      risk_factors: risk_factors,
      operational_vulnerability_score: operational_score,
      critical_exposures: identify_critical_operational_exposures(operational_gaps),
      security_recommendations: generate_operational_security_recommendations(operational_gaps)
    }
  end

  defp analyze_social_vulnerabilities(entity_data, related_data) do
    # Analyze social and organizational vulnerabilities
    social_analysis = %{
      relationship_mapping: analyze_relationship_vulnerabilities(entity_data, related_data),
      influence_networks: map_influence_vulnerabilities(entity_data, related_data),
      trust_relationships: assess_trust_relationship_risks(entity_data),
      communication_patterns: analyze_communication_patterns(entity_data),
      leadership_dependencies: identify_leadership_vulnerabilities(entity_data),
      group_dynamics: assess_group_dynamic_vulnerabilities(entity_data, related_data)
    }

    # Social engineering vectors
    social_vectors = %{
      manipulation_susceptibility: assess_manipulation_susceptibility(entity_data),
      authority_exploitation: assess_authority_exploitation_risk(entity_data),
      peer_pressure_vulnerabilities: assess_peer_pressure_risks(entity_data),
      loyalty_exploitation: assess_loyalty_exploitation_risks(entity_data)
    }

    social_score = calculate_social_vulnerability_score(social_analysis, social_vectors)

    %{
      social_analysis: social_analysis,
      exploitation_vectors: social_vectors,
      social_vulnerability_score: social_score,
      key_relationships: identify_key_vulnerable_relationships(social_analysis),
      social_engineering_recommendations: suggest_social_engineering_defenses(social_analysis)
    }
  end

  defp perform_security_assessment(entity_data, related_data) do
    # Comprehensive security posture assessment
    security_metrics = %{
      information_security_score: assess_information_security_score(entity_data, related_data),
      operational_security_score: assess_operational_security_score(entity_data),
      communication_security_score: assess_communication_security_score(entity_data),
      physical_security_score: assess_physical_security_score(entity_data),
      personnel_security_score: assess_personnel_security_score(entity_data)
    }

    # Identify security gaps
    security_gaps = identify_security_gaps(security_metrics, entity_data, related_data)

    # Calculate overall security posture
    overall_security_score = calculate_overall_security_score(security_metrics)
    security_rating = categorize_security_rating(overall_security_score)

    %{
      security_metrics: security_metrics,
      identified_gaps: security_gaps,
      overall_security_score: overall_security_score,
      security_rating: security_rating,
      priority_improvements: identify_priority_security_improvements(security_gaps),
      security_recommendations: generate_comprehensive_security_recommendations(security_gaps)
    }
  end

  defp calculate_exploitability_rating(entity_data, related_data) do
    # Calculate overall exploitability rating across all dimensions

    # Weight different vulnerability types
    weights = %{
      behavioral: 0.25,
      tactical: 0.30,
      operational: 0.25,
      social: 0.20
    }

    # Calculate individual scores from previous analysis
    behavioral_score = calculate_base_behavioral_score(entity_data, related_data)
    tactical_score = calculate_base_tactical_score(entity_data, related_data)
    operational_score = calculate_base_operational_score(entity_data, related_data)
    social_score = calculate_base_social_score(entity_data, related_data)

    # Calculate weighted overall score
    overall_score =
      behavioral_score * weights.behavioral +
        tactical_score * weights.tactical +
        operational_score * weights.operational +
        social_score * weights.social

    # Determine exploitability rating
    exploitability_rating = categorize_exploitability_rating(overall_score)

    # Identify primary attack vectors
    primary_vectors =
      identify_primary_attack_vectors(
        behavioral_score,
        tactical_score,
        operational_score,
        social_score
      )

    %{
      overall_exploitability_score: overall_score,
      exploitability_rating: exploitability_rating,
      primary_attack_vectors: primary_vectors,
      vulnerability_breakdown: %{
        behavioral: behavioral_score,
        tactical: tactical_score,
        operational: operational_score,
        social: social_score
      },
      exploitation_difficulty: assess_exploitation_difficulty(overall_score),
      exploitation_impact_potential: assess_exploitation_impact(entity_data, related_data)
    }
  end

  defp generate_vulnerability_summary(entity_data, related_data, entity_type) do
    # Generate executive summary of vulnerability assessment

    # Key findings
    key_vulnerabilities = identify_key_vulnerabilities(entity_data, related_data)
    critical_risks = identify_critical_risks(entity_data, related_data)

    # Risk prioritization
    risk_priority = prioritize_vulnerability_risks(key_vulnerabilities, critical_risks)

    # Mitigation roadmap
    mitigation_roadmap = create_mitigation_roadmap(risk_priority)

    %{
      entity_type: entity_type,
      assessment_timestamp: DateTime.utc_now(),
      overall_vulnerability_level:
        determine_overall_vulnerability_level(entity_data, related_data),
      key_vulnerabilities: key_vulnerabilities,
      critical_risks: critical_risks,
      risk_prioritization: risk_priority,
      immediate_actions_required: identify_immediate_actions(critical_risks),
      mitigation_roadmap: mitigation_roadmap,
      reassessment_recommendation: recommend_reassessment_schedule(risk_priority),
      executive_summary: create_executive_summary(key_vulnerabilities, critical_risks)
    }
  end

  # Helper functions

  defp get_entity_data(base_data, entity_id, entity_type) do
    data_key =
      case entity_type do
        :character -> :entity_data
        :corporation -> :entity_data
        :fleet -> :entity_data
      end

    entity_data = get_in(base_data, [data_key])

    if entity_data != nil do
      Result.ok(entity_data)
    else
      Result.error(:entity_not_found, "Entity data not found for #{entity_type} #{entity_id}")
    end
  end

  defp get_related_data(base_data, entity_id, entity_type) do
    # Get related data based on entity type
    related_data =
      case entity_type do
        :character ->
          base_data.related_data || %{}

        :corporation ->
          base_data.related_data || %{}

        :fleet ->
          base_data.related_data || %{}
      end

    Result.ok(related_data)
  end

  defp calculate_character_age(entity_data) do
    case entity_data.creation_date do
      nil ->
        0

      creation_date ->
        case DateTime.from_iso8601(creation_date) do
          {:ok, datetime, _} ->
            DateTime.diff(DateTime.utc_now(), datetime, :day)

          _ ->
            0
        end
    end
  end

  defp categorize_activity_level(entity_data) do
    recent_activity = (entity_data.recent_kills || 0) + (entity_data.recent_losses || 0)

    cond do
      recent_activity > 50 -> :very_high
      recent_activity > 20 -> :high
      recent_activity > 10 -> :moderate
      recent_activity > 5 -> :low
      true -> :minimal
    end
  end

  defp categorize_corp_activity_level(entity_data) do
    member_count = entity_data.member_count || 0

    cond do
      member_count > 500 -> :very_high
      member_count > 100 -> :high
      member_count > 50 -> :moderate
      member_count > 10 -> :low
      true -> :minimal
    end
  end

  # Behavioral pattern analysis

  defp extract_behavioral_patterns(entity_data, related_data) do
    if entity_data == nil or related_data == nil do
      %{}
    else
      # Extract behavioral patterns that could indicate vulnerabilities
      killmail_stats = Map.get(related_data, :killmail_stats, %{})

      %{
        activity_patterns: extract_activity_patterns(entity_data),
        engagement_patterns: extract_engagement_patterns(entity_data, killmail_stats),
        risk_patterns: extract_risk_patterns(entity_data),
        social_patterns: extract_social_patterns(entity_data),
        operational_patterns: extract_operational_patterns(entity_data),
        consistency_patterns: extract_consistency_patterns(entity_data)
      }
    end
  end

  defp extract_activity_patterns(entity_data) do
    activity_by_hour = entity_data.activity_by_hour || %{}

    %{
      peak_hours: identify_peak_activity_hours(activity_by_hour),
      activity_consistency: calculate_activity_consistency(activity_by_hour),
      timezone_predictability: assess_timezone_predictability(entity_data),
      session_patterns: infer_session_patterns(entity_data)
    }
  end

  defp extract_engagement_patterns(entity_data, killmail_stats) do
    %{
      aggression_level: entity_data.aggression_percentile || 50,
      solo_preference: entity_data.solo_ratio || 0.5,
      target_selection: analyze_target_selection_vulnerability(entity_data),
      escalation_tendency: entity_data.batphone_probability || "low",
      retreat_patterns: analyze_retreat_vulnerability(entity_data)
    }
  end

  defp extract_risk_patterns(entity_data) do
    %{
      ship_value_comfort: entity_data.avg_ship_value || 0,
      security_space_comfort: analyze_security_comfort(entity_data),
      loss_tolerance: calculate_loss_tolerance(entity_data),
      experimentation_willingness: assess_experimentation(entity_data)
    }
  end

  defp extract_social_patterns(entity_data) do
    %{
      cooperation_level: 1.0 - (entity_data.solo_ratio || 0.5),
      leadership_indicators: entity_data.is_fc || false,
      communication_frequency: estimate_communication_frequency(entity_data),
      trust_relationships: assess_trust_vulnerability(entity_data)
    }
  end

  defp extract_operational_patterns(entity_data) do
    %{
      routine_predictability: assess_routine_predictability(entity_data),
      operational_security: assess_operational_security(entity_data),
      resource_management: assess_resource_management(entity_data),
      planning_horizon: assess_planning_horizon(entity_data)
    }
  end

  defp extract_consistency_patterns(entity_data) do
    %{
      behavior_consistency: calculate_behavior_consistency(entity_data),
      performance_stability: calculate_performance_stability(entity_data),
      decision_consistency: assess_decision_consistency(entity_data)
    }
  end

  defp identify_predictable_patterns(patterns) do
    if map_size(patterns) == 0 do
      []
    else
      predictable_patterns = []

      # Analyze activity patterns for predictability
      activity_patterns = Map.get(patterns, :activity_patterns, %{})

      predictable_patterns =
        if Map.get(activity_patterns, :activity_consistency, 0) > 0.7 do
          ["consistent_activity_schedule" | predictable_patterns]
        else
          predictable_patterns
        end

      predictable_patterns =
        if Map.get(activity_patterns, :timezone_predictability, 0) > 0.8 do
          ["predictable_timezone_activity" | predictable_patterns]
        else
          predictable_patterns
        end

      # Analyze engagement patterns
      engagement_patterns = Map.get(patterns, :engagement_patterns, %{})
      solo_pref = Map.get(engagement_patterns, :solo_preference, 0.5)

      predictable_patterns =
        if solo_pref > 0.8 or solo_pref < 0.2 do
          ["rigid_engagement_style" | predictable_patterns]
        else
          predictable_patterns
        end

      # Analyze operational patterns
      operational_patterns = Map.get(patterns, :operational_patterns, %{})

      predictable_patterns =
        if Map.get(operational_patterns, :routine_predictability, 0) > 0.7 do
          ["operational_routine" | predictable_patterns]
        else
          predictable_patterns
        end

      # Analyze consistency patterns
      consistency_patterns = Map.get(patterns, :consistency_patterns, %{})

      if Map.get(consistency_patterns, :behavior_consistency, 0) > 0.8 do
        ["highly_consistent_behavior" | predictable_patterns]
      else
        predictable_patterns
      end
    end
  end

  defp identify_routine_weaknesses(patterns) do
    if map_size(patterns) == 0 do
      []
    else
      routine_weaknesses = []

      # Check for timing-based vulnerabilities
      activity_patterns = Map.get(patterns, :activity_patterns, %{})
      peak_hours = Map.get(activity_patterns, :peak_hours, [])

      routine_weaknesses =
        if length(peak_hours) <= 2 do
          ["narrow_activity_window" | routine_weaknesses]
        else
          routine_weaknesses
        end

      # Check for behavioral rigidity
      engagement_patterns = Map.get(patterns, :engagement_patterns, %{})
      solo_pref = Map.get(engagement_patterns, :solo_preference, 0.5)

      routine_weaknesses =
        if solo_pref > 0.9 do
          ["solo_dependency" | routine_weaknesses]
        else
          routine_weaknesses
        end

      routine_weaknesses =
        if solo_pref < 0.1 do
          ["fleet_dependency" | routine_weaknesses]
        else
          routine_weaknesses
        end

      # Check for operational predictability
      operational_patterns = Map.get(patterns, :operational_patterns, %{})

      routine_weaknesses =
        if Map.get(operational_patterns, :routine_predictability, 0) > 0.8 do
          ["highly_predictable_operations" | routine_weaknesses]
        else
          routine_weaknesses
        end

      # Check for risk aversion patterns
      risk_patterns = Map.get(patterns, :risk_patterns, %{})

      routine_weaknesses =
        if Map.get(risk_patterns, :ship_value_comfort, 0) < 50_000_000 do
          ["excessive_risk_aversion" | routine_weaknesses]
        else
          routine_weaknesses
        end

      # Check for social isolation
      social_patterns = Map.get(patterns, :social_patterns, %{})

      if Map.get(social_patterns, :cooperation_level, 0.5) < 0.2 do
        ["social_isolation" | routine_weaknesses]
      else
        routine_weaknesses
      end
    end
  end

  defp identify_emotional_triggers(entity_data) do
    if entity_data == nil do
      []
    else
      emotional_triggers = []

      # Loss-based triggers
      total_losses = entity_data.total_losses || 0

      emotional_triggers =
        if total_losses > 100 do
          ["loss_frustration" | emotional_triggers]
        else
          emotional_triggers
        end

      # Performance-based triggers
      kd_ratio = calculate_kd_ratio(entity_data)

      emotional_triggers =
        if kd_ratio < 0.5 do
          ["performance_anxiety" | emotional_triggers]
        else
          emotional_triggers
        end

      # Value-based triggers
      avg_ship_value = entity_data.avg_ship_value || 0

      emotional_triggers =
        if avg_ship_value > 1_000_000_000 do
          ["asset_attachment" | emotional_triggers]
        else
          emotional_triggers
        end

      # Social triggers
      emotional_triggers =
        if entity_data.is_fc == true do
          ["leadership_pressure" | emotional_triggers]
        else
          emotional_triggers
        end

      # Reputation triggers
      emotional_triggers =
        if (entity_data.security_status || 0) < -5.0 do
          ["reputation_concern" | emotional_triggers]
        else
          emotional_triggers
        end

      # Competition triggers
      aggression = entity_data.aggression_percentile || 50

      emotional_triggers =
        if aggression > 80 do
          ["competitive_pressure" | emotional_triggers]
        else
          emotional_triggers
        end

      # Isolation triggers
      solo_ratio = entity_data.solo_ratio || 0.5

      if solo_ratio > 0.8 do
        ["independence_pride" | emotional_triggers]
      else
        emotional_triggers
      end
    end
  end

  defp calculate_kd_ratio(entity_data) do
    kills = entity_data.total_kills || 0
    losses = entity_data.total_losses || 0

    if losses > 0 do
      kills / losses
    else
      min(kills, 100.0)
    end
  end

  defp analyze_decision_patterns(related_data) do
    if related_data == nil do
      %{}
    else
      # Analyze decision-making patterns from killmail data
      killmail_stats = Map.get(related_data, :killmail_stats, %{})

      %{
        risk_decision_pattern: analyze_risk_decisions(killmail_stats),
        timing_decision_pattern: analyze_timing_decisions(killmail_stats),
        target_decision_pattern: analyze_target_decisions(killmail_stats),
        escalation_decision_pattern: analyze_escalation_decisions(killmail_stats),
        retreat_decision_pattern: analyze_retreat_decisions(killmail_stats)
      }
    end
  end

  defp analyze_risk_decisions(killmail_stats) do
    # Analyze pattern of risky vs. safe decisions
    high_value_losses = Map.get(killmail_stats, "high_value_losses", 0)
    total_losses = Map.get(killmail_stats, "total_losses", 1)

    risk_ratio = high_value_losses / total_losses

    cond do
      risk_ratio > 0.5 -> :consistently_risky
      risk_ratio > 0.3 -> :moderately_risky
      risk_ratio > 0.1 -> :occasionally_risky
      true -> :risk_averse
    end
  end

  defp analyze_timing_decisions(killmail_stats) do
    # Analyze timing decision patterns
    peak_hour_kills = Map.get(killmail_stats, "peak_hour_activity", 0)
    total_activity = Map.get(killmail_stats, "total_activity", 1)

    concentration = peak_hour_kills / total_activity

    cond do
      concentration > 0.6 -> :poor_timing_opsec
      concentration > 0.4 -> :predictable_timing
      concentration > 0.2 -> :varied_timing
      true -> :unpredictable_timing
    end
  end

  defp analyze_target_decisions(killmail_stats) do
    # Analyze target selection decision patterns
    easy_targets = Map.get(killmail_stats, "easy_target_kills", 0)
    total_kills = Map.get(killmail_stats, "total_kills", 1)

    easy_ratio = easy_targets / total_kills

    cond do
      easy_ratio > 0.7 -> :opportunistic_hunter
      easy_ratio > 0.5 -> :selective_hunter
      easy_ratio > 0.3 -> :challenging_hunter
      true -> :elite_hunter
    end
  end

  defp analyze_escalation_decisions(killmail_stats) do
    # Analyze escalation decision patterns
    escalated_fights = Map.get(killmail_stats, "escalated_engagements", 0)
    total_engagements = Map.get(killmail_stats, "total_engagements", 1)

    escalation_ratio = escalated_fights / total_engagements

    cond do
      escalation_ratio > 0.4 -> :frequent_escalator
      escalation_ratio > 0.2 -> :occasional_escalator
      escalation_ratio > 0.1 -> :rare_escalator
      true -> :non_escalator
    end
  end

  defp analyze_retreat_decisions(killmail_stats) do
    # Analyze retreat decision patterns
    successful_retreats = Map.get(killmail_stats, "successful_retreats", 0)
    failed_retreats = Map.get(killmail_stats, "failed_retreats", 0)
    total_retreats = successful_retreats + failed_retreats

    if total_retreats > 0 do
      success_rate = successful_retreats / total_retreats

      cond do
        success_rate > 0.8 -> :excellent_retreat_decisions
        success_rate > 0.6 -> :good_retreat_decisions
        success_rate > 0.4 -> :poor_retreat_decisions
        true -> :terrible_retreat_decisions
      end
    else
      :no_retreat_data
    end
  end

  defp assess_social_engineering_risk(entity_data) do
    if entity_data == nil do
      :unknown
    else
      # Assess vulnerability to social engineering attacks
      risk_factors = []

      # Trust indicators
      cooperation_level = 1.0 - (entity_data.solo_ratio || 0.5)

      risk_factors =
        if cooperation_level > 0.7 do
          ["high_trust_tendency" | risk_factors]
        else
          risk_factors
        end

      # Authority susceptibility
      risk_factors =
        if entity_data.is_fc != true and cooperation_level > 0.6 do
          ["authority_susceptible" | risk_factors]
        else
          risk_factors
        end

      # Information sharing tendency
      total_activity = (entity_data.total_kills || 0) + (entity_data.total_losses || 0)

      risk_factors =
        if total_activity > 500 and cooperation_level > 0.5 do
          ["information_sharing_tendency" | risk_factors]
        else
          risk_factors
        end

      # Emotional vulnerability
      avg_ship_value = entity_data.avg_ship_value || 0

      risk_factors =
        if avg_ship_value > 2_000_000_000 do
          ["high_stakes_emotional_investment" | risk_factors]
        else
          risk_factors
        end

      # Social proof susceptibility
      risk_factors =
        if cooperation_level > 0.8 do
          ["social_proof_susceptible" | risk_factors]
        else
          risk_factors
        end

      # Calculate overall risk
      risk_score = length(risk_factors) / 5.0

      cond do
        risk_score > 0.6 -> :high_risk
        risk_score > 0.4 -> :moderate_risk
        risk_score > 0.2 -> :low_risk
        true -> :minimal_risk
      end
    end
  end

  # Simplified analysis functions returning placeholder data

  defp assess_information_leakage(_entity_data, _related_data), do: %{}
  defp calculate_behavioral_vulnerability_score(_vulnerabilities), do: 25.0

  defp identify_behavioral_exploitation_vectors(_vulnerabilities),
    do: ["timing_exploitation", "pattern_prediction"]

  defp suggest_behavioral_mitigations(_vulnerabilities),
    do: ["vary_activity_patterns", "reduce_predictability"]

  # Tactical analysis placeholders
  defp analyze_combat_vulnerability_patterns(_entity_data, _related_data),
    do: %{engagement_style: "predictable"}

  defp analyze_ship_vulnerability_patterns(_entity_data),
    do: %{preferred_ships: "limited_variety"}

  defp identify_fitting_vulnerabilities(_entity_data), do: ["standard_fits", "meta_dependency"]
  defp analyze_engagement_vulnerabilities(_entity_data), do: %{preferred_range: "close"}

  defp assess_coordination_vulnerabilities(_entity_data, _related_data),
    do: %{fleet_dependency: "high"}

  defp analyze_escape_route_vulnerabilities(_entity_data),
    do: %{escape_consistency: "predictable"}

  defp identify_ship_counter_opportunities(_entity_data),
    do: ["range_advantage", "speed_advantage"]

  defp identify_range_exploitation_opportunities(_entity_data), do: ["kiting_opportunities"]
  defp identify_timing_vulnerabilities(_entity_data), do: ["peak_hour_targeting"]
  defp identify_positioning_vulnerabilities(_entity_data), do: ["gate_positioning"]

  defp calculate_tactical_vulnerability_score(_analysis, _exploits), do: 35.0
  defp suggest_counter_strategies(_analysis), do: ["counter_ship_types", "range_control"]
  defp categorize_tactical_vulnerability(score) when score > 70, do: :high
  defp categorize_tactical_vulnerability(score) when score > 40, do: :moderate
  defp categorize_tactical_vulnerability(_), do: :low

  # Operational analysis placeholders
  defp assess_security_practices(_entity_data), do: %{opsec_level: "moderate"}
  defp assess_information_security(_entity_data, _related_data), do: %{data_exposure: "minimal"}
  defp identify_operational_patterns(_entity_data, _related_data), do: %{routine_level: "high"}
  defp assess_asset_exposure_risk(_entity_data), do: %{exposure_level: "moderate"}
  defp assess_communication_vulnerabilities(_entity_data), do: %{comms_security: "standard"}
  defp identify_logistical_weaknesses(_entity_data), do: ["supply_predictability"]

  defp assess_insider_threat_risk(_entity_data), do: :low
  defp assess_supply_chain_risks(_entity_data), do: :moderate
  defp assess_operational_tempo_vulnerabilities(_entity_data), do: :low
  defp assess_geographic_vulnerabilities(_entity_data), do: %{home_system_dependency: "high"}

  defp calculate_operational_vulnerability_score(_gaps, _factors), do: 30.0
  defp identify_critical_operational_exposures(_gaps), do: ["routine_predictability"]

  defp generate_operational_security_recommendations(_gaps),
    do: ["vary_operations", "improve_opsec"]

  # Social analysis placeholders
  defp analyze_relationship_vulnerabilities(_entity_data, _related_data),
    do: %{corp_dependency: "high"}

  defp map_influence_vulnerabilities(_entity_data, _related_data),
    do: %{leadership_influence: "strong"}

  defp assess_trust_relationship_risks(_entity_data), do: %{trust_level: "high"}
  defp identify_leadership_vulnerabilities(_entity_data), do: ["fc_dependency"]

  defp assess_group_dynamic_vulnerabilities(_entity_data, _related_data),
    do: %{group_cohesion: "strong"}

  defp analyze_communication_patterns(_entity_data), do: %{communication_frequency: "regular"}

  defp assess_manipulation_susceptibility(_entity_data), do: :moderate
  defp assess_authority_exploitation_risk(_entity_data), do: :moderate
  defp assess_peer_pressure_risks(_entity_data), do: :low
  defp assess_loyalty_exploitation_risks(_entity_data), do: :moderate

  defp calculate_social_vulnerability_score(_analysis, _vectors), do: 20.0

  defp identify_key_vulnerable_relationships(_analysis),
    do: ["corp_leadership", "fleet_commanders"]

  defp suggest_social_engineering_defenses(_analysis),
    do: ["trust_verification", "information_compartmentalization"]

  # Security assessment placeholders
  defp assess_information_security_score(_entity_data, _related_data), do: 60.0
  defp assess_operational_security_score(_entity_data), do: 55.0
  defp assess_communication_security_score(_entity_data), do: 65.0
  defp assess_physical_security_score(_entity_data), do: 70.0
  defp assess_personnel_security_score(_entity_data), do: 60.0

  defp identify_security_gaps(_metrics, _entity_data, _related_data),
    do: ["timing_patterns", "communication_leaks"]

  defp calculate_overall_security_score(metrics) do
    scores = [
      metrics.information_security_score,
      metrics.operational_security_score,
      metrics.communication_security_score,
      metrics.physical_security_score,
      metrics.personnel_security_score
    ]

    Enum.sum(scores) / length(scores)
  end

  defp categorize_security_rating(score) when score > 80, do: :excellent
  defp categorize_security_rating(score) when score > 60, do: :good
  defp categorize_security_rating(score) when score > 40, do: :fair
  defp categorize_security_rating(_), do: :poor

  defp identify_priority_security_improvements(_gaps),
    do: ["improve_timing_opsec", "secure_communications"]

  defp generate_comprehensive_security_recommendations(_gaps),
    do: ["operational_security_training", "pattern_disruption"]

  # Exploitability calculation helpers
  defp calculate_base_behavioral_score(entity_data, _related_data) do
    # Simple scoring based on predictability factors
    solo_ratio = entity_data.solo_ratio || 0.5
    activity_predictability = if solo_ratio > 0.8 or solo_ratio < 0.2, do: 30, else: 10
    Float.round(activity_predictability, 1)
  end

  defp calculate_base_tactical_score(entity_data, _related_data) do
    # Simple scoring based on combat patterns
    aggression = entity_data.aggression_percentile || 50
    tactical_predictability = if aggression > 80, do: 40, else: 20
    Float.round(tactical_predictability, 1)
  end

  defp calculate_base_operational_score(entity_data, _related_data) do
    # Simple scoring based on operational patterns
    avg_value = entity_data.avg_ship_value || 0
    risk_exposure = if avg_value > 1_000_000_000, do: 35, else: 15
    Float.round(risk_exposure, 1)
  end

  defp calculate_base_social_score(entity_data, _related_data) do
    # Simple scoring based on social factors
    cooperation = 1.0 - (entity_data.solo_ratio || 0.5)
    social_exposure = cooperation * 30
    Float.round(social_exposure, 1)
  end

  defp categorize_exploitability_rating(score) when score > 70, do: :highly_exploitable
  defp categorize_exploitability_rating(score) when score > 50, do: :moderately_exploitable
  defp categorize_exploitability_rating(score) when score > 30, do: :low_exploitability
  defp categorize_exploitability_rating(_), do: :minimal_exploitability

  defp identify_primary_attack_vectors(behavioral, tactical, operational, social) do
    scores = [
      {:behavioral, behavioral},
      {:tactical, tactical},
      {:operational, operational},
      {:social, social}
    ]

    scores
    |> Enum.sort_by(fn {_type, score} -> score end, :desc)
    |> Enum.take(2)
    |> Enum.map(fn {type, _score} -> type end)
  end

  defp assess_exploitation_difficulty(score) when score > 70, do: :easy
  defp assess_exploitation_difficulty(score) when score > 50, do: :moderate
  defp assess_exploitation_difficulty(_), do: :difficult

  defp assess_exploitation_impact(_entity_data, _related_data), do: :moderate

  # Summary generation placeholders
  defp identify_key_vulnerabilities(_entity_data, _related_data) do
    ["predictable_activity_patterns", "limited_ship_variety", "social_engineering_susceptibility"]
  end

  defp identify_critical_risks(_entity_data, _related_data) do
    ["timing_based_targeting", "fleet_dependency"]
  end

  defp prioritize_vulnerability_risks(key_vulnerabilities, critical_risks) do
    %{
      high: critical_risks,
      medium: Enum.take(key_vulnerabilities, 2),
      low: Enum.drop(key_vulnerabilities, 2)
    }
  end

  defp create_mitigation_roadmap(risk_priority) do
    %{
      immediate: risk_priority.high,
      short_term: risk_priority.medium,
      long_term: risk_priority.low
    }
  end

  defp determine_overall_vulnerability_level(_entity_data, _related_data), do: :moderate

  defp identify_immediate_actions(critical_risks) do
    Enum.map(critical_risks, fn risk -> "address_#{risk}" end)
  end

  defp recommend_reassessment_schedule(_risk_priority), do: "quarterly"

  defp create_executive_summary(key_vulnerabilities, critical_risks) do
    vuln_count = length(key_vulnerabilities)
    critical_count = length(critical_risks)

    "Vulnerability assessment identified #{vuln_count} key vulnerabilities and #{critical_count} critical risks. " <>
      "Primary concerns include behavioral predictability and tactical limitations. " <>
      "Immediate attention required for timing-based vulnerabilities."
  end

  # Placeholder helper functions
  defp identify_peak_activity_hours(activity_by_hour) do
    if map_size(activity_by_hour) == 0 do
      []
    else
      activity_by_hour
      |> Enum.sort_by(fn {_hour, activity} -> activity end, :desc)
      |> Enum.take(3)
      |> Enum.map(fn {hour, _activity} -> hour end)
    end
  end

  defp calculate_activity_consistency(_activity_by_hour), do: 0.7
  defp assess_timezone_predictability(_entity_data), do: 0.8
  defp infer_session_patterns(_entity_data), do: "regular_sessions"
  defp analyze_target_selection_vulnerability(_entity_data), do: "predictable"
  defp analyze_retreat_vulnerability(_entity_data), do: "poor_timing"
  defp analyze_security_comfort(_entity_data), do: "null_sec_comfortable"
  defp calculate_loss_tolerance(_entity_data), do: "moderate"
  defp assess_experimentation(_entity_data), do: "low"
  defp estimate_communication_frequency(_entity_data), do: "regular"
  defp assess_trust_vulnerability(_entity_data), do: "high_trust"
  defp assess_routine_predictability(_entity_data), do: 0.8
  defp assess_operational_security(_entity_data), do: "standard"
  defp assess_resource_management(_entity_data), do: "efficient"
  defp assess_planning_horizon(_entity_data), do: "short_term"
  defp calculate_behavior_consistency(_entity_data), do: 0.9
  defp calculate_performance_stability(_entity_data), do: 0.7
  defp assess_decision_consistency(_entity_data), do: "consistent"
end
