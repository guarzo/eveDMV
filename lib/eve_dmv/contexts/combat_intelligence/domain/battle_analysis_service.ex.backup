defmodule EveDmv.Contexts.CombatIntelligence.Domain.BattleAnalysisService do
  @moduledoc """
  Advanced battle analysis service for EVE DMV Combat Intelligence.

  Provides comprehensive battle analytics including:
  - Real-time engagement tracking and analysis
  - Fleet composition effectiveness evaluation
  - Tactical timeline reconstruction
  - Combat pattern recognition
  - Post-battle performance metrics
  - Tactical recommendations generation

  This service processes killmail data to provide actionable intelligence
  for fleet commanders and strategic planners.
  """

  use GenServer
  use EveDmv.ErrorHandler

  # alias EveDmv.Contexts.CombatIntelligence.Infrastructure.BattleCache
  # alias EveDmv.Contexts.CombatIntelligence.Infrastructure.KillmailRepository
  # alias EveDmv.Contexts.FleetOperations.Domain.FleetAnalyzer
  # alias EveDmv.Contexts.ThreatAssessment.Analyzers.ThreatAnalyzer
  alias EveDmv.DomainEvents.BattleAnalysisComplete
  alias EveDmv.DomainEvents.TacticalInsightGenerated
  alias EveDmv.Infrastructure.EventBus

  require Logger

  # Battle classification thresholds
  @small_gang_max 10
  @medium_fleet_max 50

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @doc """
  Analyze a battle or engagement from killmail data.

  Provides comprehensive analysis including timeline, fleet composition,
  tactical effectiveness, and strategic recommendations.
  """
  def analyze_battle(battle_id, opts \\ []) do
    GenServer.call(__MODULE__, {:analyze_battle, battle_id, opts})
  end

  @doc """
  Analyze an ongoing engagement in real-time.

  Tracks developing battles and provides live tactical insights.
  """
  def analyze_live_engagement(system_id, opts \\ []) do
    GenServer.call(__MODULE__, {:analyze_live_engagement, system_id, opts})
  end

  @doc """
  Generate tactical recommendations based on battle analysis.
  """
  def generate_tactical_recommendations(battle_analysis) do
    GenServer.call(__MODULE__, {:generate_recommendations, battle_analysis})
  end

  @doc """
  Get battle timeline for visualization.
  """
  def get_battle_timeline(battle_id, opts \\ []) do
    GenServer.call(__MODULE__, {:get_battle_timeline, battle_id, opts})
  end

  @doc """
  Compare multiple battles for pattern analysis.
  """
  def compare_battles(battle_ids, opts \\ []) do
    GenServer.call(__MODULE__, {:compare_battles, battle_ids, opts})
  end

  @doc """
  Get performance metrics for a specific entity in battles.
  """
  def get_entity_battle_performance(entity_id, entity_type, opts \\ []) do
    GenServer.call(__MODULE__, {:get_entity_performance, entity_id, entity_type, opts})
  end

  # GenServer implementation

  @impl GenServer
  def init(_opts) do
    # Subscribe to killmail events for real-time analysis
    Phoenix.PubSub.subscribe(EveDmv.PubSub, "killmails:enriched")

    state = %{
      # system_id -> engagement_data
      active_engagements: %{},
      # battle_id -> analysis_cache
      battle_cache: %{},
      metrics: %{
        battles_analyzed: 0,
        recommendations_generated: 0,
        active_engagements_tracked: 0
      }
    }

    # Schedule periodic engagement cleanup
    Process.send_after(self(), :cleanup_stale_engagements, 60_000)

    Logger.info("BattleAnalysisService started")
    {:ok, state}
  end

  @impl GenServer
  def handle_call({:analyze_battle, battle_id, _opts}, _from, state) do
    # Check cache first
    case Map.get(state.battle_cache, battle_id) do
      nil ->
        # Perform full analysis
        case fetch_battle_killmails(battle_id) do
          {:error, :not_implemented} ->
            {:reply, {:error, :not_implemented}, state}

          {:ok, killmails} ->
            with {:ok, timeline} <- construct_battle_timeline(killmails),
                 {:ok, participants} <- extract_battle_participants(killmails),
                 {:ok, fleet_analysis} <- analyze_fleet_compositions(participants, killmails),
                 {:ok, tactical_analysis} <- perform_tactical_analysis(timeline, fleet_analysis),
                 {:ok, performance_metrics} <-
                   calculate_performance_metrics(killmails, participants) do
              analysis = %{
                battle_id: battle_id,
                analyzed_at: DateTime.utc_now(),

                # Battle overview
                duration_seconds: calculate_battle_duration(timeline),
                total_participants: map_size(participants),
                total_kills: length(killmails),
                isk_destroyed: calculate_total_isk_destroyed(killmails),

                # Classification
                battle_type: classify_battle_type(participants, killmails),
                engagement_scale: classify_engagement_scale(participants),

                # Timeline
                timeline: timeline,
                phases: identify_battle_phases(timeline),

                # Fleet analysis
                fleet_compositions: fleet_analysis,
                doctrine_effectiveness: evaluate_doctrine_effectiveness(fleet_analysis),

                # Tactical analysis
                tactical_patterns: tactical_analysis.patterns,
                key_moments: tactical_analysis.key_moments,
                turning_points: tactical_analysis.turning_points,

                # Performance
                side_performance: performance_metrics.by_side,
                ship_class_effectiveness: performance_metrics.by_ship_class,
                top_performers: performance_metrics.top_performers,

                # Strategic insights
                winner: determine_battle_winner(performance_metrics),
                victory_factors: analyze_victory_factors(tactical_analysis, performance_metrics)
              }

              # Cache the analysis
              new_cache = Map.put(state.battle_cache, battle_id, analysis)

              new_metrics = %{
                state.metrics
                | battles_analyzed: state.metrics.battles_analyzed + 1
              }

              new_state = %{state | battle_cache: new_cache, metrics: new_metrics}

              # Publish analysis complete event
              EventBus.publish(%BattleAnalysisComplete{
                battle_id: battle_id,
                battle_type: analysis.battle_type,
                participant_count: analysis.total_participants,
                isk_destroyed: analysis.isk_destroyed,
                timestamp: DateTime.utc_now()
              })

              {:reply, {:ok, analysis}, new_state}
            else
              {:error, _reason} = error -> {:reply, error, state}
            end
        end

      cached_analysis ->
        # Return cached analysis
        {:reply, {:ok, cached_analysis}, state}
    end
  rescue
    exception ->
      Logger.error("Battle analysis error: #{inspect(exception)}")
      {:reply, {:error, :analysis_failed}, state}
  end

  @impl GenServer
  def handle_call({:analyze_live_engagement, system_id, _opts}, _from, state) do
    # Get or create engagement tracking
    engagement =
      Map.get(state.active_engagements, system_id, %{
        system_id: system_id,
        started_at: DateTime.utc_now(),
        killmails: [],
        participants: %{},
        last_activity: DateTime.utc_now()
      })

    # Fetch recent killmails
    case fetch_recent_system_kills(system_id, 300) do
      {:error, :not_implemented} ->
        {:reply, {:error, :not_implemented}, state}

      {:ok, recent_kills} ->
        with {:ok, updated_engagement} <- update_engagement_data(engagement, recent_kills),
             {:ok, live_analysis} <- perform_live_analysis(updated_engagement) do
          # Update state
          new_engagements = Map.put(state.active_engagements, system_id, updated_engagement)
          new_state = %{state | active_engagements: new_engagements}

          {:reply, {:ok, live_analysis}, new_state}
        else
          {:error, _reason} = error -> {:reply, error, state}
        end
    end
  rescue
    exception ->
      Logger.error("Live engagement analysis error: #{inspect(exception)}")
      {:reply, {:error, :live_analysis_failed}, state}
  end

  @impl GenServer
  def handle_call({:generate_recommendations, battle_analysis}, _from, state) do
    recommendations = %{
      tactical: do_generate_tactical_recommendations(battle_analysis),
      strategic: generate_strategic_recommendations(battle_analysis),
      doctrine: generate_doctrine_recommendations(battle_analysis),
      training: generate_training_recommendations(battle_analysis)
    }

    # Update metrics
    new_metrics = %{
      state.metrics
      | recommendations_generated: state.metrics.recommendations_generated + 1
    }

    new_state = %{state | metrics: new_metrics}

    # Publish tactical insight event
    EventBus.publish(%TacticalInsightGenerated{
      battle_id: battle_analysis.battle_id,
      insight_type: :recommendations,
      recommendations: recommendations,
      timestamp: DateTime.utc_now()
    })

    {:reply, {:ok, recommendations}, new_state}
  rescue
    exception ->
      Logger.error("Recommendation generation error: #{inspect(exception)}")
      {:reply, {:error, :recommendation_generation_failed}, state}
  end

  @impl GenServer
  def handle_call({:get_battle_timeline, battle_id, opts}, _from, state) do
    with {:ok, killmails} <- fetch_battle_killmails(battle_id),
         {:ok, timeline} <- construct_detailed_timeline(killmails, opts) do
      timeline_data = %{
        battle_id: battle_id,
        events: timeline,
        duration: calculate_timeline_duration(timeline),
        intensity_curve: calculate_intensity_curve(timeline),
        participant_flow: track_participant_flow(timeline)
      }

      {:reply, {:ok, timeline_data}, state}
    else
      {:error, _reason} = error -> {:reply, error, state}
    end
  rescue
    exception ->
      Logger.error("Timeline generation error: #{inspect(exception)}")
      {:reply, {:error, :timeline_generation_failed}, state}
  end

  @impl GenServer
  def handle_call({:compare_battles, battle_ids, _opts}, _from, state) do
    # Analyze each battle
    battle_analyses =
      Enum.map(battle_ids, fn battle_id ->
        case Map.get(state.battle_cache, battle_id) do
          nil ->
            # Trigger analysis if not cached
            case handle_call({:analyze_battle, battle_id, []}, nil, state) do
              {:reply, {:ok, analysis}, _state} -> analysis
              _ -> nil
            end

          cached ->
            cached
        end
      end)

    comparison = %{
      battles: battle_analyses,
      common_patterns: identify_common_patterns(battle_analyses),
      tactical_evolution: analyze_tactical_evolution(battle_analyses),
      effectiveness_trends: compare_effectiveness_trends(battle_analyses),
      doctrine_comparison: compare_doctrine_usage(battle_analyses)
    }

    {:reply, {:ok, comparison}, state}
  rescue
    exception ->
      Logger.error("Battle comparison error: #{inspect(exception)}")
      {:reply, {:error, :comparison_failed}, state}
  end

  @impl GenServer
  def handle_call({:get_entity_performance, entity_id, entity_type, opts}, _from, state) do
    time_range = Keyword.get(opts, :time_range, :last_30_days)

    with {:ok, battles} <- fetch_entity_battles(entity_id, entity_type, time_range),
         {:ok, performance_data} <- analyze_entity_performance(entity_id, entity_type, battles) do
      {:reply, {:ok, performance_data}, state}
    else
      {:error, _reason} = error -> {:reply, error, state}
    end
  rescue
    exception ->
      Logger.error("Entity performance analysis error: #{inspect(exception)}")
      {:reply, {:error, :performance_analysis_failed}, state}
  end

  @impl GenServer
  def handle_info({:killmail_enriched, killmail}, state) do
    # Track live engagements
    if killmail.system_id do
      engagement =
        Map.get(state.active_engagements, killmail.system_id, %{
          system_id: killmail.system_id,
          started_at: DateTime.utc_now(),
          killmails: [],
          participants: %{},
          last_activity: DateTime.utc_now()
        })

      updated_engagement = %{
        engagement
        | killmails: [killmail | engagement.killmails],
          last_activity: DateTime.utc_now()
      }

      new_engagements = Map.put(state.active_engagements, killmail.system_id, updated_engagement)
      new_state = %{state | active_engagements: new_engagements}

      {:noreply, new_state}
    else
      {:noreply, state}
    end
  end

  @impl GenServer
  def handle_info(:cleanup_stale_engagements, state) do
    # Remove engagements with no activity for 10 minutes
    cutoff_time = DateTime.add(DateTime.utc_now(), -600, :second)

    active_engagements =
      state.active_engagements
      |> Enum.filter(fn {_system_id, engagement} ->
        DateTime.compare(engagement.last_activity, cutoff_time) == :gt
      end)
      |> Map.new()

    # Schedule next cleanup
    Process.send_after(self(), :cleanup_stale_engagements, 60_000)

    {:noreply, %{state | active_engagements: active_engagements}}
  end

  # Private functions

  defp fetch_battle_killmails(battle_id) do
    # For now, use battle_id as a system_id and time window
    # In a real implementation, this would query based on battle clustering logic
    try do
      case Ash.read(EveDmv.Killmails.KillmailRaw, domain: EveDmv.Api) do
        {:ok, killmails} ->
          # Filter killmails for this "battle" (simplified approach)
          battle_killmails =
            killmails
            |> Enum.filter(fn km ->
              # Use battle_id as system_id for now
              km.solar_system_id == battle_id
            end)
            # Limit to prevent excessive processing
            |> Enum.take(100)

          {:ok, battle_killmails}

        error ->
          error
      end
    catch
      error -> {:error, error}
    end
  end

  defp fetch_recent_system_kills(system_id, seconds_back) do
    cutoff_time = DateTime.add(DateTime.utc_now(), -seconds_back, :second)

    try do
      case Ash.read(EveDmv.Killmails.KillmailRaw, domain: EveDmv.Api) do
        {:ok, killmails} ->
          recent_kills =
            killmails
            |> Enum.filter(fn km ->
              km.solar_system_id == system_id and
                km.killmail_time && DateTime.compare(km.killmail_time, cutoff_time) == :gt
            end)
            |> Enum.sort_by(& &1.killmail_time, {:desc, DateTime})
            # Limit to most recent 50 kills
            |> Enum.take(50)

          {:ok, recent_kills}

        error ->
          error
      end
    catch
      error -> {:error, error}
    end
  end

  defp construct_battle_timeline(killmails) do
    timeline =
      killmails
      |> Enum.sort_by(& &1.killmail_time)
      |> Enum.map(fn km ->
        %{
          timestamp: km.killmail_time,
          event_type: :kill,
          victim: %{
            character_id: km.victim_character_id,
            corporation_id: km.victim_corporation_id,
            ship_type_id: km.victim_ship_type_id
          },
          attackers_count: length(km.attackers || []),
          final_blow: find_final_blow_attacker(km.attackers),
          isk_value: km.total_value
        }
      end)

    {:ok, timeline}
  end

  defp construct_detailed_timeline(killmails, opts) do
    include_damage_dealt = Keyword.get(opts, :include_damage, true)

    timeline =
      killmails
      |> Enum.sort_by(& &1.killmail_time)
      |> Enum.map(fn km ->
        event = %{
          timestamp: km.killmail_time,
          event_type: :kill,
          killmail_id: km.killmail_id,
          system_id: km.system_id,
          victim: extract_victim_details(km),
          attackers: if(include_damage_dealt, do: extract_attacker_details(km), else: nil),
          isk_destroyed: km.total_value,
          ship_class: classify_ship(km.victim_ship_type_id)
        }

        event
      end)

    {:ok, timeline}
  end

  defp extract_battle_participants(killmails) do
    participants =
      Enum.reduce(killmails, %{}, fn km, acc ->
        # Add victim
        acc =
          Map.put(acc, km.victim_character_id, %{
            character_id: km.victim_character_id,
            corporation_id: km.victim_corporation_id,
            alliance_id: km.victim_alliance_id,
            side: determine_side(km.victim_corporation_id, km.victim_alliance_id),
            kills: 0,
            losses: 1,
            damage_dealt: 0,
            ships_used: MapSet.new([km.victim_ship_type_id])
          })

        # Add attackers
        Enum.reduce(km.attackers || [], acc, fn attacker, acc2 ->
          char_id = attacker["character_id"]

          if char_id && char_id != 0 do
            existing =
              Map.get(acc2, char_id, %{
                character_id: char_id,
                corporation_id: attacker["corporation_id"],
                alliance_id: attacker["alliance_id"],
                side: determine_side(attacker["corporation_id"], attacker["alliance_id"]),
                kills: 0,
                losses: 0,
                damage_dealt: 0,
                ships_used: MapSet.new()
              })

            updated = %{
              existing
              | kills: existing.kills + if(attacker["final_blow"], do: 1, else: 0),
                damage_dealt: existing.damage_dealt + (attacker["damage_done"] || 0),
                ships_used: MapSet.put(existing.ships_used, attacker["ship_type_id"])
            }

            Map.put(acc2, char_id, updated)
          else
            acc2
          end
        end)
      end)

    {:ok, participants}
  end

  defp analyze_fleet_compositions(participants, _killmails) do
    # Group participants by side
    sides =
      participants
      |> Map.values()
      |> Enum.group_by(& &1.side)

    fleet_comps =
      Map.new(sides, fn {side, side_participants} ->
        ship_composition = analyze_side_ship_composition(side_participants)

        {side,
         %{
           pilot_count: length(side_participants),
           ship_composition: ship_composition,
           doctrine_detected: detect_doctrine_usage(ship_composition),
           average_pilot_efficiency: calculate_average_efficiency(side_participants),
           logistics_ratio: calculate_logistics_ratio(ship_composition),
           ewar_presence: detect_ewar_presence(ship_composition)
         }}
      end)

    {:ok, fleet_comps}
  end

  defp perform_tactical_analysis(timeline, fleet_analysis) do
    analysis = %{
      patterns: identify_tactical_patterns(timeline),
      key_moments: identify_key_moments(timeline),
      turning_points: identify_turning_points(timeline, fleet_analysis),
      engagement_flow: analyze_engagement_flow(timeline),
      focus_fire_effectiveness: analyze_focus_fire(timeline),
      target_selection: analyze_target_selection(timeline, fleet_analysis)
    }

    {:ok, analysis}
  end

  defp calculate_performance_metrics(killmails, participants) do
    # Group by side
    sides =
      participants
      |> Map.values()
      |> Enum.group_by(& &1.side)

    by_side =
      sides
      |> Enum.map(fn {side, side_participants} ->
        {side,
         %{
           kills: Enum.sum(Enum.map(side_participants, & &1.kills)),
           losses: Enum.sum(Enum.map(side_participants, & &1.losses)),
           isk_destroyed: calculate_side_isk_destroyed(side, killmails),
           isk_lost: calculate_side_isk_lost(side, killmails),
           efficiency: calculate_side_efficiency(side, killmails),
           k_d_ratio: calculate_side_kd_ratio(side_participants)
         }}
      end)
      |> Map.new()

    by_ship_class = analyze_ship_class_performance(killmails, participants)
    top_performers = identify_top_performers(participants)

    {:ok,
     %{
       by_side: by_side,
       by_ship_class: by_ship_class,
       top_performers: top_performers
     }}
  end

  defp update_engagement_data(engagement, new_kills) do
    # Add new kills to engagement
    all_kills = engagement.killmails ++ new_kills

    # Update participants
    participants =
      Enum.reduce(all_kills, engagement.participants, fn _km, acc ->
        # Similar logic to extract_battle_participants but incremental
        acc
      end)

    updated = %{
      engagement
      | killmails: all_kills,
        participants: participants,
        last_activity: DateTime.utc_now()
    }

    {:ok, updated}
  end

  defp perform_live_analysis(engagement) do
    # Quick analysis for live engagement
    participant_count = map_size(engagement.participants)
    kill_rate = calculate_kill_rate(engagement.killmails)

    analysis = %{
      system_id: engagement.system_id,
      status: determine_engagement_status(engagement),
      duration_seconds: DateTime.diff(DateTime.utc_now(), engagement.started_at),
      participant_count: participant_count,
      kill_count: length(engagement.killmails),
      kill_rate_per_minute: kill_rate,
      engagement_intensity: calculate_engagement_intensity(kill_rate, participant_count),
      likely_outcome: predict_engagement_outcome(engagement)
    }

    {:ok, analysis}
  end

  defp do_generate_tactical_recommendations(battle_analysis) do
    initial_recommendations = []

    # Fleet composition recommendations
    composition_recommendations =
      initial_recommendations ++
        if battle_analysis.fleet_compositions do
          analyze_fleet_composition_gaps(battle_analysis.fleet_compositions)
        else
          []
        end

    # Tactical pattern recommendations
    final_recommendations =
      composition_recommendations ++
        if battle_analysis.tactical_patterns do
          generate_pattern_based_recommendations(battle_analysis.tactical_patterns)
        else
          []
        end

    final_recommendations
  end

  defp generate_strategic_recommendations(battle_analysis) do
    Enum.filter(
      [
        analyze_strategic_positioning(battle_analysis),
        recommend_force_multiplication(battle_analysis),
        suggest_engagement_timing(battle_analysis)
      ],
      &(&1 != nil)
    )
  end

  defp generate_doctrine_recommendations(battle_analysis) do
    fleet_comps = battle_analysis.fleet_compositions

    if fleet_comps do
      Enum.filter(
        [
          recommend_doctrine_adjustments(fleet_comps),
          suggest_counter_doctrines(fleet_comps),
          identify_doctrine_weaknesses(fleet_comps)
        ],
        &(&1 != nil)
      )
    else
      []
    end
  end

  defp generate_training_recommendations(battle_analysis) do
    Enum.filter(
      [
        identify_skill_gaps(battle_analysis),
        recommend_practice_scenarios(battle_analysis),
        suggest_role_specializations(battle_analysis)
      ],
      &(&1 != nil)
    )
  end

  # Helper functions

  defp calculate_battle_duration(timeline) do
    if Enum.empty?(timeline) do
      0
    else
      first_event = List.first(timeline)
      last_event = List.last(timeline)
      DateTime.diff(last_event.timestamp, first_event.timestamp)
    end
  end

  defp calculate_total_isk_destroyed(killmails) do
    Enum.sum(Enum.map(killmails, &(&1.total_value || 0)))
  end

  defp classify_battle_type(participants, _killmails) do
    participant_count = map_size(participants)

    cond do
      participant_count <= @small_gang_max -> :small_gang
      participant_count <= @medium_fleet_max -> :fleet_fight
      true -> :large_scale_battle
    end
  end

  defp classify_engagement_scale(participants) do
    count = map_size(participants)

    cond do
      count < 5 -> :skirmish
      count < 15 -> :small_gang
      count < 30 -> :medium_gang
      count < 75 -> :fleet
      count < 150 -> :large_fleet
      true -> :massive_battle
    end
  end

  defp identify_battle_phases(_timeline) do
    # Identify distinct phases based on kill intensity
    []
  end

  defp determine_side(corporation_id, alliance_id) do
    # Logic to determine which side a participant is on
    # This would use corporation/alliance standings or other logic
    # For now, simple hash-based assignment
    hash = :erlang.phash2({corporation_id, alliance_id})
    if rem(hash, 2) == 0, do: :side_a, else: :side_b
  end

  defp find_final_blow_attacker(attackers) do
    Enum.find(attackers, &(&1["final_blow"] == true))
  end

  defp classify_ship(ship_type_id) do
    # Use EVE item types to classify ships
    case Ash.read(EveDmv.Eve.ItemType, domain: EveDmv.Api) do
      {:ok, item_types} ->
        case Enum.find(item_types, &(&1.type_id == ship_type_id)) do
          nil ->
            :unknown

          item_type ->
            case item_type.category_name do
              "Ship" -> classify_ship_by_group(item_type.type_name)
              _ -> :unknown
            end
        end

      _ ->
        :unknown
    end
  end

  defp extract_victim_details(killmail) do
    %{
      character_id: killmail.victim_character_id,
      character_name: killmail.victim_character_name,
      corporation_id: killmail.victim_corporation_id,
      corporation_name: killmail.victim_corporation_name,
      alliance_id: killmail.victim_alliance_id,
      alliance_name: killmail.victim_alliance_name,
      ship_type_id: killmail.victim_ship_type_id,
      ship_name: killmail.victim_ship_name
    }
  end

  defp extract_attacker_details(killmail) do
    Enum.map(killmail.attackers, fn attacker ->
      %{
        character_id: attacker["character_id"],
        character_name: attacker["character_name"],
        corporation_id: attacker["corporation_id"],
        corporation_name: attacker["corporation_name"],
        ship_type_id: attacker["ship_type_id"],
        weapon_type_id: attacker["weapon_type_id"],
        damage_done: attacker["damage_done"],
        final_blow: attacker["final_blow"]
      }
    end)
  end

  defp analyze_side_ship_composition(participants) do
    participants
    |> Enum.flat_map(&MapSet.to_list(&1.ships_used))
    |> Enum.frequencies()
  end

  defp detect_doctrine_usage(_ship_composition) do
    # Detect common doctrine patterns
    nil
  end

  defp calculate_average_efficiency(participants) do
    total_kills = Enum.sum(Enum.map(participants, & &1.kills))
    total_losses = Enum.sum(Enum.map(participants, & &1.losses))

    if total_losses > 0 do
      total_kills / total_losses
    else
      total_kills
    end
  end

  defp calculate_logistics_ratio(ship_composition) do
    # Calculate logistics ship ratio
    logistics_ships =
      Enum.filter(ship_composition, fn {ship_name, _count} ->
        String.contains?(String.downcase(ship_name), [
          "logistics",
          "guardian",
          "basilisk",
          "scimitar",
          "oneiros"
        ])
      end)

    total_ships = Enum.sum(Enum.map(ship_composition, fn {_ship, count} -> count end))
    logistics_count = Enum.sum(Enum.map(logistics_ships, fn {_ship, count} -> count end))

    if total_ships > 0 do
      logistics_count / total_ships
    else
      0.0
    end
  end

  defp detect_ewar_presence(ship_composition) do
    # Detect electronic warfare ships
    ewar_ships =
      Enum.any?(ship_composition, fn {ship_name, _count} ->
        ship_name_lower = String.downcase(ship_name)

        String.contains?(ship_name_lower, [
          "falcon",
          "rook",
          "scorpion",
          "widow",
          "blackbird",
          "kitsune",
          "griffin",
          "huginn",
          "rapier",
          "pilgrim",
          "curse",
          "arbitrator",
          "sentinel",
          "crucifier",
          "malediction",
          "keres",
          "hyena",
          "vigil"
        ])
      end)

    ewar_ships
  end

  defp identify_tactical_patterns(timeline) do
    # Analyze timeline for tactical patterns
    patterns = []

    # Check for alpha strike patterns (many kills in short time)
    patterns =
      if has_alpha_strike_pattern(timeline) do
        [%{type: :alpha_strike, description: "Coordinated alpha strike detected"}] ++ patterns
      else
        patterns
      end

    # Check for focus fire patterns
    patterns =
      if has_focus_fire_pattern(timeline) do
        [%{type: :focus_fire, description: "Focus fire tactics identified"}] ++ patterns
      else
        patterns
      end

    # Check for kiting patterns
    patterns =
      if has_kiting_pattern(timeline) do
        [%{type: :kiting, description: "Hit and run tactics observed"}] ++ patterns
      else
        patterns
      end

    patterns
  end

  defp identify_key_moments(timeline) do
    # Identify key moments in battle timeline
    key_moments = []

    # Find high-value kills
    high_value_kills =
      Enum.filter(timeline, fn event ->
        # 1B+ ISK kills
        event.isk_value && event.isk_value > 1_000_000_000
      end)

    key_moments =
      Enum.map(high_value_kills, fn kill ->
        %{
          timestamp: kill.timestamp,
          type: :high_value_kill,
          description: "High-value target eliminated",
          isk_value: kill.isk_value,
          victim: kill.victim
        }
      end) ++ key_moments

    # Find rapid kill sequences (potential alpha strikes)
    rapid_sequences = find_rapid_kill_sequences(timeline)
    key_moments = rapid_sequences ++ key_moments

    # Sort by timestamp
    Enum.sort_by(key_moments, & &1.timestamp)
  end

  defp identify_turning_points(_timeline, _fleet_analysis) do
    # TODO: Implement real turning point analysis
    # Requires: Analyze momentum shifts in battle
    # Original stub returned: []
    []
  end

  defp analyze_engagement_flow(_timeline) do
    # TODO: Implement real engagement flow analysis
    # Requires: Analyze kill clustering and tempo changes
    # Original stub returned: %{phases: [], intensity_changes: []}
    %{
      phases: [],
      intensity_changes: []
    }
  end

  defp analyze_focus_fire(_timeline) do
    # TODO: Implement real focus fire analysis
    # Requires: Analyze damage concentration patterns
    # Original stub returned: %{effectiveness: 0.0, coordination_score: 0.0}
    %{
      effectiveness: nil,
      coordination_score: nil
    }
  end

  defp analyze_target_selection(timeline, fleet_analysis) do
    try do
      # Identify high-value targets based on ship types and fittings
      high_value_targets = identify_high_value_targets(timeline, fleet_analysis)
      
      # Calculate how many high-value targets were actually eliminated
      {priority_kills, total_kills} = calculate_priority_target_performance(timeline, high_value_targets)
      
      # Analyze target switching patterns
      switching_analysis = analyze_target_switching_patterns(timeline)
      
      # Calculate timing efficiency of target selection
      timing_efficiency = calculate_target_timing_efficiency(timeline, high_value_targets)
      
      %{
        priority_targets_hit: if(total_kills > 0, do: priority_kills / total_kills * 100, else: 0.0),
        target_switching_rate: switching_analysis.average_switch_time,
        high_value_targets_identified: length(high_value_targets),
        high_value_targets_eliminated: priority_kills,
        target_focus_score: calculate_target_focus_score(timeline),
        timing_efficiency: timing_efficiency,
        primary_target_preference: analyze_primary_target_preference(timeline),
        target_selection_quality: assess_target_selection_quality(timeline, fleet_analysis)
      }
    rescue
      error ->
        Logger.error("Error analyzing target selection: #{inspect(error)}")
        %{
          priority_targets_hit: 0.0,
          target_switching_rate: 0.0,
          error: :analysis_failed
        }
    end
  end

  defp calculate_side_isk_destroyed(side, killmails) do
    try do
      # Find kills where this side was involved as attackers
      kills_by_side =
        Enum.filter(killmails, fn killmail ->
          # Check if any attacker belongs to this side
          Enum.any?(killmail.attackers, fn attacker ->
            attacker_side = determine_character_side(attacker.character_id, side)
            attacker_side == side
          end)
        end)

      # Sum the total value of all kills
      total_destroyed =
        kills_by_side
        |> Enum.map(fn killmail ->
          case killmail do
            %{total_value: value} when is_number(value) -> value
            _ -> 0
          end
        end)
        |> Enum.sum()

      total_destroyed
    rescue
      error ->
        Logger.error(
          "Error calculating ISK destroyed for side #{inspect(side)}: #{inspect(error)}"
        )

        0
    end
  end

  defp calculate_side_isk_lost(side, killmails) do
    try do
      # Find kills where this side was the victim
      losses =
        Enum.filter(killmails, fn killmail ->
          victim_side = determine_character_side(killmail.victim.character_id, side)
          victim_side == side
        end)

      # Sum the total value of all losses
      total_lost =
        losses
        |> Enum.map(fn killmail ->
          case killmail do
            %{total_value: value} when is_number(value) -> value
            _ -> 0
          end
        end)
        |> Enum.sum()

      total_lost
    rescue
      error ->
        Logger.error("Error calculating ISK lost for side #{inspect(side)}: #{inspect(error)}")
        0
    end
  end

  defp calculate_side_efficiency(side, killmails) do
    try do
      # Calculate ISK destroyed by this side
      isk_destroyed = calculate_side_isk_destroyed(side, killmails)

      # Calculate ISK lost by this side
      isk_lost = calculate_side_isk_lost(side, killmails)

      # Calculate efficiency: destroyed / (destroyed + lost) * 100
      total_isk_involvement = isk_destroyed + isk_lost

      if total_isk_involvement > 0 do
        efficiency = isk_destroyed / total_isk_involvement * 100
        Float.round(efficiency, 2)
      else
        # No ISK involvement means no meaningful efficiency calculation
        0.0
      end
    rescue
      error ->
        Logger.error("Error calculating side efficiency: #{inspect(error)}")
        0.0
    end
  end

  defp calculate_side_kd_ratio(_participants) do
    1.0
  end

  defp analyze_ship_class_performance(_killmails, _participants) do
    %{}
  end

  defp identify_top_performers(participants) do
    participants
    |> Map.values()
    |> Enum.sort_by(& &1.kills, :desc)
    |> Enum.take(10)
  end

  defp calculate_kill_rate(killmails) do
    if Enum.empty?(killmails) do
      0.0
    else
      first_kill = List.first(killmails)
      last_kill = List.last(killmails)
      duration_minutes = DateTime.diff(last_kill.killmail_time, first_kill.killmail_time) / 60

      if duration_minutes > 0 do
        length(killmails) / duration_minutes
      else
        0.0
      end
    end
  end

  defp determine_engagement_status(engagement) do
    last_activity_seconds = DateTime.diff(DateTime.utc_now(), engagement.last_activity)

    cond do
      last_activity_seconds < 60 -> :active
      last_activity_seconds < 300 -> :winding_down
      true -> :concluded
    end
  end

  defp calculate_engagement_intensity(kill_rate, participant_count) do
    if participant_count > 0 do
      intensity = kill_rate * 10 / participant_count

      cond do
        intensity > 2.0 -> :extreme
        intensity > 1.0 -> :high
        intensity > 0.5 -> :moderate
        intensity > 0.2 -> :low
        true -> :minimal
      end
    else
      :minimal
    end
  end

  defp predict_engagement_outcome(_engagement) do
    # Simple prediction based on current kill ratio
    %{
      likely_winner: :undetermined,
      confidence: :low
    }
  end

  defp calculate_timeline_duration(timeline) do
    if Enum.empty?(timeline) do
      0
    else
      first = List.first(timeline)
      last = List.last(timeline)
      DateTime.diff(last.timestamp, first.timestamp)
    end
  end

  defp calculate_intensity_curve(_timeline) do
    # Calculate kills per minute over time
    []
  end

  defp track_participant_flow(_timeline) do
    # Track when participants join/leave battle
    %{
      joiners: [],
      leavers: []
    }
  end

  defp identify_common_patterns(_battle_analyses) do
    []
  end

  defp analyze_tactical_evolution(_battle_analyses) do
    []
  end

  defp compare_effectiveness_trends(_battle_analyses) do
    %{}
  end

  defp compare_doctrine_usage(_battle_analyses) do
    %{}
  end

  defp fetch_entity_battles(_entity_id, _entity_type, _time_range) do
    {:ok, []}
  end

  defp analyze_entity_performance(entity_id, entity_type, battles) do
    {:ok,
     %{
       entity_id: entity_id,
       entity_type: entity_type,
       battle_count: length(battles),
       win_rate: 0.0,
       average_efficiency: 100.0,
       preferred_doctrines: [],
       performance_trend: :stable
     }}
  end

  defp analyze_fleet_composition_gaps(_fleet_compositions) do
    []
  end

  defp generate_pattern_based_recommendations(_patterns) do
    []
  end

  defp analyze_strategic_positioning(_battle_analysis) do
    nil
  end

  defp recommend_force_multiplication(_battle_analysis) do
    nil
  end

  defp suggest_engagement_timing(_battle_analysis) do
    nil
  end

  defp recommend_doctrine_adjustments(_fleet_comps) do
    nil
  end

  defp suggest_counter_doctrines(_fleet_comps) do
    nil
  end

  defp identify_doctrine_weaknesses(_fleet_comps) do
    nil
  end

  defp identify_skill_gaps(_battle_analysis) do
    nil
  end

  defp recommend_practice_scenarios(_battle_analysis) do
    nil
  end

  defp suggest_role_specializations(_battle_analysis) do
    nil
  end

  defp evaluate_doctrine_effectiveness(_fleet_analysis) do
    %{}
  end

  defp determine_battle_winner(_performance_metrics) do
    :undetermined
  end

  defp analyze_victory_factors(tactical_analysis, performance_metrics) do
    initial_factors = []

    # Analyze numerical superiority
    numerical_factors =
      initial_factors ++
        case performance_metrics.by_side do
          nil -> []
          by_side -> analyze_numerical_factors(by_side)
        end

    # Analyze tactical effectiveness
    tactical_factors =
      numerical_factors ++
        case tactical_analysis.patterns do
          nil -> []
          patterns -> analyze_tactical_factors(patterns)
        end

    # Analyze engagement control
    control_factors =
      tactical_factors ++
        case tactical_analysis.key_moments do
          nil -> []
          key_moments -> analyze_control_factors(key_moments)
        end

    control_factors
  end

  defp analyze_numerical_factors(side_performance) do
    # Analyze if numbers played a decisive role
    side_counts =
      Enum.map(side_performance, fn {_side, metrics} ->
        metrics.kills + metrics.losses
      end)

    if length(side_counts) >= 2 do
      [max_count, second_count | _] = Enum.sort(side_counts, :desc)

      if max_count > second_count * 1.5 do
        ["Numerical superiority was decisive"]
      else
        []
      end
    else
      []
    end
  end

  defp analyze_tactical_factors(patterns) do
    # Analyze tactical patterns for victory factors
    if Enum.any?(patterns, &(&1.type == :coordinated_alpha)) do
      ["Superior coordination and focus fire"]
    else
      []
    end
  end

  defp analyze_control_factors(key_moments) do
    # Analyze battlefield control moments
    if length(key_moments) > 0 do
      ["Effective battlefield control"]
    else
      []
    end
  end

  # Additional helper functions for battle analysis

  defp classify_ship_by_group(ship_name) do
    ship_name_lower = String.downcase(ship_name)

    cond do
      String.contains?(ship_name_lower, [
        "frigate",
        "interceptor",
        "assault frigate",
        "stealth bomber",
        "electronic attack ship"
      ]) ->
        :frigate

      String.contains?(ship_name_lower, ["destroyer", "interdiction", "tactical destroyer"]) ->
        :destroyer

      String.contains?(ship_name_lower, [
        "cruiser",
        "heavy interdiction cruiser",
        "recon ship",
        "logistics cruiser",
        "strategic cruiser"
      ]) ->
        :cruiser

      String.contains?(ship_name_lower, ["battlecruiser", "command ship"]) ->
        :battlecruiser

      String.contains?(ship_name_lower, ["battleship", "marauder", "black ops"]) ->
        :battleship

      String.contains?(ship_name_lower, [
        "carrier",
        "dreadnought",
        "force auxiliary",
        "supercarrier",
        "titan"
      ]) ->
        :capital

      String.contains?(ship_name_lower, ["industrial", "transport", "hauler"]) ->
        :industrial

      true ->
        :unknown
    end
  end

  defp has_alpha_strike_pattern(timeline) do
    # Check if there are multiple kills within a short timeframe
    if length(timeline) < 3, do: false

    # Look for 3+ kills within 30 seconds
    Enum.any?(0..(length(timeline) - 3), fn i ->
      events = Enum.slice(timeline, i, 3)
      first_event = List.first(events)
      last_event = List.last(events)

      if first_event && last_event do
        time_diff = DateTime.diff(last_event.timestamp, first_event.timestamp)
        time_diff <= 30
      else
        false
      end
    end)
  end

  defp has_focus_fire_pattern(timeline) do
    # Check if similar ship types are being targeted consistently
    if length(timeline) < 5, do: false

    # Group by ship type and check for patterns
    ship_types =
      Enum.map(timeline, fn event ->
        event.victim.ship_type_id
      end)

    # If same ship type appears frequently, it might indicate focus fire
    ship_frequencies = Enum.frequencies(ship_types)
    max_frequency = Enum.max(Map.values(ship_frequencies))

    max_frequency >= 3 and max_frequency / length(timeline) > 0.3
  end

  defp has_kiting_pattern(timeline) do
    # Simple heuristic: if there are gaps in the timeline, it might indicate kiting
    if length(timeline) < 3, do: false

    # Check for time gaps between kills
    time_gaps =
      timeline
      |> Enum.chunk_every(2, 1, :discard)
      |> Enum.map(fn [first, second] ->
        DateTime.diff(second.timestamp, first.timestamp)
      end)

    # If there are significant gaps, it might indicate kiting
    avg_gap = Enum.sum(time_gaps) / length(time_gaps)
    # Average gap > 60 seconds
    avg_gap > 60
  end

  defp find_rapid_kill_sequences(timeline) do
    # Find sequences of rapid kills
    timeline
    |> Enum.chunk_every(3, 1, :discard)
    |> Enum.filter(fn [first, _, third] ->
      # 3 kills in 10 seconds
      DateTime.diff(third.timestamp, first.timestamp) <= 10
    end)
    |> Enum.map(fn [first, _, _] ->
      %{
        timestamp: first.timestamp,
        type: :rapid_sequence,
        description: "Rapid kill sequence detected"
      }
    end)
  end

  # Target selection analysis helper functions
  
  defp identify_high_value_targets(timeline, fleet_analysis) do
    # Identify ships that are high-value targets based on type and role
    timeline
    |> Enum.filter(fn event ->
      ship_type_id = Map.get(event, :victim_ship_type_id)
      ship_value = Map.get(event, :isk_value, 0)
      
      # High value if expensive ship or strategic role
      ship_value > 500_000_000 or is_strategic_ship_type(ship_type_id)
    end)
    |> Enum.map(fn event ->
      %{
        character_id: event.victim.character_id,
        ship_type_id: event.victim_ship_type_id,
        isk_value: Map.get(event, :isk_value, 0),
        timestamp: event.timestamp,
        strategic_importance: calculate_ship_strategic_value(event.victim_ship_type_id)
      }
    end)
  end
  
  defp calculate_priority_target_performance(timeline, high_value_targets) do
    total_kills = length(timeline)
    
    priority_kills = 
      Enum.count(high_value_targets, fn target ->
        Enum.any?(timeline, fn event ->
          event.victim.character_id == target.character_id and
          event.victim_ship_type_id == target.ship_type_id
        end)
      end)
    
    {priority_kills, total_kills}
  end
  
  defp analyze_target_switching_patterns(timeline) do
    # Group kills by time windows to identify switching patterns
    sorted_timeline = Enum.sort_by(timeline, & &1.timestamp, DateTime)
    
    time_windows = 
      sorted_timeline
      |> Enum.chunk_every(5)  # Groups of 5 kills
      |> Enum.map(fn window ->
        targets = Enum.map(window, & &1.victim.character_id) |> Enum.uniq()
        %{
          start_time: List.first(window).timestamp,
          end_time: List.last(window).timestamp,
          unique_targets: length(targets),
          total_kills: length(window)
        }
      end)
    
    avg_switch_time = 
      if length(time_windows) > 1 do
        total_duration = 
          time_windows
          |> Enum.map(fn window ->
            DateTime.diff(window.end_time, window.start_time, :second)
          end)
          |> Enum.sum()
        
        total_duration / length(time_windows)
      else
        0
      end
    
    %{
      average_switch_time: avg_switch_time,
      focus_windows: time_windows,
      target_diversity: calculate_target_diversity(timeline)
    }
  end
  
  defp calculate_target_timing_efficiency(timeline, high_value_targets) do
    if length(high_value_targets) == 0 do
      0.0
    else
      # Calculate how quickly high-value targets were eliminated
      sorted_timeline = Enum.sort_by(timeline, & &1.timestamp, DateTime)
      
      early_priority_kills = 
        sorted_timeline
        |> Enum.take(div(length(sorted_timeline), 3))  # First third of battle
        |> Enum.count(fn event ->
          Enum.any?(high_value_targets, fn target ->
            event.victim.character_id == target.character_id
          end)
        end)
      
      if length(high_value_targets) > 0 do
        early_priority_kills / length(high_value_targets) * 100
      else
        0.0
      end
    end
  end
  
  defp calculate_target_focus_score(timeline) do
    # Calculate how focused the fleet was on specific targets
    target_counts = 
      timeline
      |> Enum.group_by(& &1.victim.character_id)
      |> Enum.map(fn {_, kills} -> length(kills) end)
    
    if length(target_counts) > 0 do
      max_kills_on_single_target = Enum.max(target_counts)
      total_kills = Enum.sum(target_counts)
      
      max_kills_on_single_target / total_kills * 100
    else
      0.0
    end
  end
  
  defp analyze_primary_target_preference(timeline) do
    # Analyze what types of ships are primarily targeted
    ship_type_targets = 
      timeline
      |> Enum.group_by(& &1.victim_ship_type_id)
      |> Enum.map(fn {ship_type, kills} -> 
        {ship_type, length(kills), get_ship_class(ship_type)}
      end)
      |> Enum.sort_by(fn {_, count, _} -> count end, :desc)
    
    primary_preferences = 
      ship_type_targets
      |> Enum.take(3)
      |> Enum.map(fn {ship_type, count, ship_class} ->
        %{
          ship_type_id: ship_type,
          kill_count: count,
          ship_class: ship_class,
          percentage: count / length(timeline) * 100
        }
      end)
    
    %{
      primary_targets: primary_preferences,
      target_diversity: length(ship_type_targets),
      focused_targeting: calculate_targeting_focus(ship_type_targets)
    }
  end
  
  defp assess_target_selection_quality(timeline, fleet_analysis) do
    # Overall assessment of target selection quality
    threat_elimination = calculate_threat_elimination_score(timeline)
    value_destruction = calculate_value_destruction_efficiency(timeline)
    tactical_impact = assess_tactical_impact(timeline, fleet_analysis)
    
    overall_score = (threat_elimination + value_destruction + tactical_impact) / 3
    
    %{
      overall_quality_score: overall_score,
      threat_elimination: threat_elimination,
      value_destruction: value_destruction,
      tactical_impact: tactical_impact,
      quality_grade: grade_quality_score(overall_score)
    }
  end
  
  # Helper functions for target analysis
  
  defp is_strategic_ship_type(ship_type_id) do
    # This would check against a database of ship types
    # For now, use some common strategic ship type IDs (examples)
    strategic_types = [
      # Force Auxiliaries, Dreadnoughts, Carriers, Supercarriers, Titans
      37604, 37605, 37606, 37607, 37608,  # Placeholder IDs
      # Command Ships, Strategic Cruisers
      30842, 30843, 30844, 30845,
      # Logistics
      33472, 33473, 33474, 33475
    ]
    
    ship_type_id in strategic_types
  end
  
  defp calculate_ship_strategic_value(ship_type_id) do
    cond do
      is_strategic_ship_type(ship_type_id) -> :high
      true -> :normal
    end
  end
  
  defp calculate_target_diversity(timeline) do
    unique_targets = 
      timeline
      |> Enum.map(& &1.victim.character_id)
      |> Enum.uniq()
      |> length()
    
    total_kills = length(timeline)
    
    if total_kills > 0 do
      unique_targets / total_kills
    else
      0.0
    end
  end
  
  defp get_ship_class(ship_type_id) do
    # This would query the ship type database
    # For now, return generic classifications
    cond do
      ship_type_id in [0..999] -> :frigate
      ship_type_id in [1000..1999] -> :destroyer
      ship_type_id in [2000..2999] -> :cruiser
      ship_type_id in [3000..3999] -> :battlecruiser
      ship_type_id in [4000..4999] -> :battleship
      ship_type_id in [30000..39999] -> :capital
      true -> :unknown
    end
  end
  
  defp calculate_targeting_focus(ship_type_targets) do
    if length(ship_type_targets) == 0 do
      0.0
    else
      total_kills = Enum.sum(Enum.map(ship_type_targets, fn {_, count, _} -> count end))
      top_target_kills = 
        ship_type_targets
        |> Enum.take(3)
        |> Enum.map(fn {_, count, _} -> count end)
        |> Enum.sum()
      
      if total_kills > 0 do
        top_target_kills / total_kills * 100
      else
        0.0
      end
    end
  end
  
  defp calculate_threat_elimination_score(timeline) do
    # Score based on eliminating dangerous/strategic targets
    strategic_kills = 
      Enum.count(timeline, fn event ->
        is_strategic_ship_type(event.victim_ship_type_id)
      end)
    
    total_kills = length(timeline)
    
    if total_kills > 0 do
      strategic_kills / total_kills * 100
    else
      0.0
    end
  end
  
  defp calculate_value_destruction_efficiency(timeline) do
    # Score based on ISK efficiency of target selection
    high_value_kills = 
      Enum.count(timeline, fn event ->
        Map.get(event, :isk_value, 0) > 100_000_000
      end)
    
    total_kills = length(timeline)
    
    if total_kills > 0 do
      high_value_kills / total_kills * 100
    else
      0.0
    end
  end
  
  defp assess_tactical_impact(timeline, _fleet_analysis) do
    # Assess the tactical impact of target choices
    # This is a simplified implementation
    logi_kills = 
      Enum.count(timeline, fn event ->
        ship_class = get_ship_class(event.victim_ship_type_id)
        ship_class in [:logistics, :force_auxiliary]
      end)
    
    command_kills = 
      Enum.count(timeline, fn event ->
        ship_class = get_ship_class(event.victim_ship_type_id)
        ship_class in [:command_ship, :strategic_cruiser]
      end)
    
    total_kills = length(timeline)
    
    if total_kills > 0 do
      (logi_kills * 2 + command_kills * 1.5) / total_kills * 100
    else
      0.0
    end
  end
  
  defp grade_quality_score(score) do
    cond do
      score >= 80 -> :excellent
      score >= 60 -> :good
      score >= 40 -> :average
      score >= 20 -> :poor
      true -> :very_poor
    end
  end

  # Helper function to determine which side a character belongs to
  defp determine_character_side(character_id, target_side) do
    # This is a simplified implementation. In a real system, this would:
    # 1. Query character/corporation/alliance standings
    # 2. Check for blue/red status
    # 3. Use configured side definitions for the battle

    # For now, we'll use a basic heuristic based on the target side structure
    case target_side do
      %{characters: chars} when is_list(chars) ->
        if character_id in chars, do: target_side, else: :other_side

      %{corporations: corps} when is_list(corps) ->
        # Would need to look up character's corporation
        # For now, return other_side if not explicitly in character list
        :other_side

      %{alliances: alliances} when is_list(alliances) ->
        # Would need to look up character's alliance
        # For now, return other_side if not explicitly listed
        :other_side

      _ ->
        # If side structure is unclear, classify as other side
        :other_side
    end
  end
end
